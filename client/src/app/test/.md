"use client";
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
import { Card, CardContent } from "@/components/ui/card";
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import { Mic, MicOff } from "lucide-react";

/**
 * Main component with two tabs:
 *   1. Browser TTS Voices Tester
 *   2. Speech‑to‑Text (Voice‑to‑Text) Live Demo
 */
export default function SpeechPlayground() {
  return (
    <div className="min-h-screen bg-gray-50 flex flex-col items-center p-6 gap-6">
      <h1 className="text-4xl font-bold mb-4 text-center">Speech Playground</h1>
      <Tabs defaultValue="tts" className="w-full max-w-3xl">
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="tts">Text → Speech</TabsTrigger>
          <TabsTrigger value="stt">Speech → Text</TabsTrigger>
        </TabsList>
        <TabsContent value="tts">
          <TtsTester />
        </TabsContent>
        <TabsContent value="stt">
          <SttTester />
        </TabsContent>
      </Tabs>
    </div>
  );
}

/** TEXT‑TO‑SPEECH COMPONENT **/
function TtsTester() {
  const [voices, setVoices] = useState<SpeechSynthesisVoice[]>([]);
  const [selectedVoice, setSelectedVoice] = useState<string>("");
  const [text, setText] = useState("Hello, this is a browser voice test.");
  const [rate, setRate] = useState(1);
  const [pitch, setPitch] = useState(1);
  const [volume, setVolume] = useState(1);

  useEffect(() => {
    const loadVoices = () => {
      const v = window.speechSynthesis.getVoices();
      setVoices(v);
      if (v.length && !selectedVoice) setSelectedVoice(v[0].voiceURI);
    };
    loadVoices();
    window.speechSynthesis.onvoiceschanged = loadVoices;
  }, [selectedVoice]);

  const speak = () => {
    if (!text.trim()) return;
    const utter = new SpeechSynthesisUtterance(text);
    const voiceObj = voices.find((v) => v.voiceURI === selectedVoice);
    if (voiceObj) utter.voice = voiceObj;
    utter.rate = rate;
    utter.pitch = pitch;
    utter.volume = volume;
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(utter);
  };

  return (
    <Card className="p-6 space-y-4 shadow-xl">
      <CardContent className="space-y-4">
        <Label htmlFor="voiceSelect">Voice</Label>
        <select
          id="voiceSelect"
          className="w-full p-2 rounded-xl border border-gray-300 focus:outline-none"
          value={selectedVoice}
          onChange={(e) => setSelectedVoice(e.target.value)}
        >
          {voices.map((v) => (
            <option key={v.voiceURI} value={v.voiceURI}>
              {v.name} — {v.lang} {v.default ? "(Default)" : ""}
            </option>
          ))}
        </select>

        <Label htmlFor="textInput">Text to Speak</Label>
        <Input
          id="textInput"
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Enter text here..."
        />

        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {([
            { label: "Rate", state: rate, set: setRate, min: 0.1, max: 4, step: 0.1 },
            { label: "Pitch", state: pitch, set: setPitch, min: 0, max: 2, step: 0.1 },
            { label: "Volume", state: volume, set: setVolume, min: 0, max: 1, step: 0.05 },
          ] as const).map(({ label, state, set, min, max, step }) => (
            <div key={label}>
              <Label>
                {label}: {state.toFixed(2)}
              </Label>
              <Slider
                min={min}
                max={max}
                step={step}
                value={[state]}
                onValueChange={(v) => set(v[0])}
              />
            </div>
          ))}
        </div>
        <Button className="w-full text-lg py-6 mt-4" onClick={speak}>
          Speak
        </Button>
      </CardContent>
    </Card>
  );
}

/** SPEECH‑TO‑TEXT COMPONENT **/
function SttTester() {
  const [supported, setSupported] = useState<boolean>(false);
  const [listening, setListening] = useState(false);
  const [transcript, setTranscript] = useState<string>("");
  const [lang, setLang] = useState("en-US");
  const [error, setError] = useState<string | null>(null);
  const [interimText, setInterimText] = useState<string>("");

  // @ts-ignore – vendor prefixes
  const SpeechRecognition =
    typeof window !== "undefined" &&
    (window.SpeechRecognition || window.webkitSpeechRecognition);

  useEffect(() => {
    setSupported(Boolean(SpeechRecognition));
  }, []);

  const toggleListening = () => {
    if (!SpeechRecognition) return;
    if (listening) {
      window.speechRecognition?.stop();
      return;
    }
    const recognition = new SpeechRecognition();
    // @ts-ignore
    window.speechRecognition = recognition;
    recognition.lang = lang;
    recognition.interimResults = true;
    recognition.continuous = true;

    recognition.onresult = (e: SpeechRecognitionEvent) => {
      let interim = "";
      for (let i = e.resultIndex; i < e.results.length; ++i) {
        const result = e.results[i];
        const spoken = result[0].transcript;

        if (result.isFinal) {
          setTranscript((prev) => {
            const full = prev + spoken + " ";
            // Check for "laugh" and trigger a TTS laugh
            if (spoken.toLowerCase().includes("laugh")) {
              const utter = new SpeechSynthesisUtterance("ha ha ha ha!");
              utter.lang = lang;
              utter.pitch = 1;
              utter.rate = 1;
              utter.volume = 1;
              window.speechSynthesis.speak(utter);
            }
            return full;
          });
        } else {
          interim += spoken;
        }
      }
      setInterimText(interim);
    };

    recognition.onerror = (e: any) => {
      setError(e.error);
      setListening(false);
    };
    recognition.onend = () => setListening(false);

    recognition.start();
    setTranscript("");
    setError(null);
    setListening(true);
  };

  return (
    <Card className="p-6 shadow-xl space-y-4">
      {!supported && (
        <p className="text-red-500">Your browser does not support Speech Recognition.</p>
      )}
      {supported && (
        <>
          <Label htmlFor="langSelect">Language</Label>
          <select
            id="langSelect"
            className="w-full p-2 rounded-xl border border-gray-300 focus:outline-none"
            value={lang}
            onChange={(e) => setLang(e.target.value)}
          >
            {[{ code: "en-US", label: "English (US)" },
              { code: "en-GB", label: "English (UK)" },
              { code: "es-ES", label: "Spanish (Spain)" },
              { code: "fr-FR", label: "French" },
              { code: "de-DE", label: "German" }].map((l) => (
              <option key={l.code} value={l.code}>
                {l.label}
              </option>
            ))}
          </select>

          <Button
            className="flex items-center gap-2 w-full text-lg py-6"
            onClick={toggleListening}
          >
            {listening ? <MicOff size={20} /> : <Mic size={20} />} {listening ? "Stop" : "Start"} Listening
          </Button>

          {error && <p className="text-red-500">Error: {error}</p>}

          <div className="min-h-[150px] bg-white rounded-xl border border-gray-300 p-4 mt-2 whitespace-pre-wrap overflow-auto">
            {transcript || interimText || "Say something..."}
          </div>
        </>
      )}
    </Card>
  );
}
